<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      h1 {
        text-align: center;
      }

      .container {
        margin: 0 auto;
        padding: 60px 20%;
      }

      figure {
        text-align: center;
      }

      img {
        display: inline-block;
      }

      body {
        font-family: "Inter", sans-serif;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Final Project Report: Semi-Automated Vector Based 2D Cel Shading</h1>
      <div style="text-align: center">
        Names: Noah Abji, Siyona Sarma, Ian Wong, Jay Yoo
      </div>

      <!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

      <h1>Abstract</h1>
      <p>
        We have added two new tools to the Pencil2D drawing program to support semi-automated 2D cel shading
        and half-tone shading. The first tool enables the user to add a new light
        source 
        and configure the direction of the light. The second tool performs the cell
        shading process on the selected object
        with a user
        
      </p>

      <h1>Technical Approach</h1>

      <h2>
        Implementation
      </h2>
      <h3>
        Assumptions
      </h3>
      <p>
        We make the following assumptions to use our semi-automatic shading algorithm - vector images (shapes drawn on the canvas) have a sinusoidal shape in the axis towards the light source. Additionally, we assume all vector images the user draws in the layer where they use our tool have a properly closed border (failure to do this can cause unexpected behavior)
      </p>
      <h3>
        Determining the Shade Contour
      </h3>
      <p>
        At a high level - the shade contour can be determined by casting a ray through an arbitrary click point. We assume a sinusoidal shape of the vector image in the direction of the light source. Using this assumed sinusoidal shape, we can determine where the light ray intersects with the sinusoid above the click point and record a shade as the projection of that point onto the 2D canvas. However, one advantage of our algorithm is that it operates entirely in 2D space - with the only 3D point we record being the light source itself so we can raise or lower it with respect to the canvas. We assume the camera also is a positive and infinite Z distance away from the plane (so a normalized ray cast towards the camera would always be [0, 0, 1]). Once we have determined this shade point, we use the direction spawned by the closest shade point to create a search interval for another arbitrary point in the vector image. We then determine the shade point similarly along the sinusoid in the direction of the light source relative to that point, and continue this iteration in both directions until we exit the border of the vector image. We decrease the search interval if this happens so the edge of the contour is also smooth and converges with the edge of the vector image. Once we have determined the series of shade points, we add the ordered series of border intersections (the side of which changes depending on convexity/concavity), which we then draw a bezier curve through to determine the shade area. A visual of this process is below.
      </p>

      <table>
        <tr>
          <td>
            <img src="shading1.png" width="400px">
          </td>
          <td>
            <img src="shading2.png width=400px">
          </td>
        </tr>
      </table>

      <h3>
        Determining a Shade Point
      </h3>
      <p>
        For a concave sinusoid can determine a shade point by casting a ray through the point p and determining the inclination angle of that ray, Θ, assuming the point is at z = 0. We can determine where the ray intersects with the vector image, which is defined by a bezier curve, with a pre-existing iterative algorithm. Once the near and far intersections, Nn and Nf are determined (Nn being closer to the light source), we can use theta to determine the proper distance vector for which to interpolate across the vector image in 2D space with the following equation: \(S_i = N_f + \cos(\theta)\frac{N_n - N_f}{2}\)
      </p>
      <p>
        For a convex shape, we simply switch Nn and Nf, and use the list of Nn as the border points.

      </p>

      <h2>
        Problems Encountered
      </h2>

      <p>
        We encountered a lot of initial difficulty when figuring out how to implement convex shading. Translating a 3-D light ray to a 2-D set of points required complex calculations, not all of which were detailed in the paper that we were referencing. Additionally, after implementing the base algorithm, there were lots of different artifacts relating to shape continuity, intersections between the shadow and the shape border, intersections between multiple shadows, and more. These all had to be individually fixed.
      </p>

      <p>
        Aside from the algorithm, we also faced difficulty when implementing graphic elements for our algorithm. Although it existed, we couldn't actually test it until we had a way to interact with the scene. This required us to wade through the code base and learn about using real-time signals from Qt, the framework that the GUI was based off of, to do things like create new layers, tools, and light positions. 
      </p>

      <h2>
        Lessons Learned
      </h2>

      <p>
        We learned a lot about the 3-D to 2-D shadow creation algorithm. Although some things were more straightforward to implement from class, like specularity on our objects, we also had to implement some novel algorithms from the paper. We had a written description and some mathematical formulas to work off of, but that was it. 
      </p>

      <h1>Results</h1>

      <a href="https://drive.google.com/file/d/18rgiaVKANNgcgHGBhn7y1Wy3TP-NQdl7/view?usp=sharing"><b>Video link</b></a>
	    
      <h1>References</h1>
      <p>Software: Pencil2D–developed in C++, using QT framework. Pencil2D is open source with a fairly active contributor base.
      <br />
      Paper Citation (<a target="_blank" href="https://dl-acm-org.libproxy.berkeley.edu/doi/pdf/10.1145/3229147.3229148">LINK</a>)
      <br />
      Hudon, Matis, et al. “2D Shading for Cel Animation.” Proceedings of the Joint Symposium on Computational Aesthetics and Sketch-Based Interfaces and Modeling and Non-Photorealistic Animation and Rendering, ACM, 2018, pp. 1–12, https://doi.org/10.1145/3229147.3229148.
      <br />
      <br />
      Cel Shading Resources
      <ul>
        <li><a href="https://www.theseus.fi/bitstream/handle/10024/787699/Kahari_Roni.pdf?sequence=3&isAllowed=y">What is Cel Shading?</a></li>
        <li><a href="https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=4134d230132b3639aef4c8e05557beea8c94ae81">Cel Shading Techniques</a></li>
        <li><a href="https://dl.acm.org/doi/abs/10.1145/3229147.3229148">Cel Shading Semi-Automatic Method for Animation</a></li>
        <li><a href="https://www.cs.rpi.edu/~cutler/classes/advancedgraphics/S12/final_projects/hutchins_kim.pdf">Cel Shading - Highlight/Texture Techniques (uses OpenGL!)</a></li>
      </ul>

      <h1>Contributions from each team member</h1>

      <p>
        Noah implemented the brunt of the algorithm for the light ray, convex points, and populating the shadow.
      </p>
      <p>
        Ian worked on self shading, as well as fixing artifacts for various discontinuities and gaps.
      </p>
      <p>
        Siyona worked on implementing halftone shading.
      </p>
      <p>
        Jay worked on fixing visual artifacts and GUI elements.
      </p>
    </div>
  </body>
</html>
